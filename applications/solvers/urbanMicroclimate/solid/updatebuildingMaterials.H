#include "buildingMaterialModel.H"

forAll(Materials, MaterialsI)
{
    const dictionary& dict = Materials[MaterialsI];

    const word cellZoneName(dict.lookup("name"));
    const word cellZoneModel(dict.lookup("buildingMaterialModel"));
    const scalar rho_(readScalar(dict.lookup("rho")));
    const scalar cap_(readScalar(dict.lookup("cap")));
    const scalar lambda1_(readScalar(dict.lookup("lambda1")));
    const scalar lambda2_(readScalar(dict.lookup("lambda2")));

    //create the buildingMaterial model
    autoPtr<buildingMaterialModel> buildingMaterial
    (
       buildingMaterialModel::New("buildingMaterial", dict, cellZoneModel)
    );
    
    label cellZoneID = mesh.cellZones().findZoneID(cellZoneName);
    if (cellZoneID == -1)
    {
        Info << "Something is wrong, cannot find at least one of the necessary cellZones! Exiting!" << endl;
        Foam::FatalError();
    }
    const labelList& cells = mesh.cellZones()[cellZoneID];
    const polyBoundaryMesh& patches = mesh.boundaryMesh();
    boolList zoneCell(mesh.nCells(), false); 
    

    forAll(cells, cellsI)
    {
        label celli = cells[cellsI];
        cellType[celli] = MaterialsI;
        zoneCell[celli] = true;
        

        buildingMaterial->update_w_C_cell(pc,ws,Crel,celli);
        buildingMaterial->update_Krel_cell(pc,ws,Krel,celli);
        buildingMaterial->update_Kv_cell(pc,ws,Ts,K_v,celli);
        rho_m.internalField()[celli] = rho_;
        cap_m.internalField()[celli] = cap_;
        lambda_m.internalField()[celli] = lambda1_ + lambda2_*ws[celli];
        buildingMaterial->update_Kpt_cell(pc,ws,Ts,K_pt,celli);
    }
}

ws.correctBoundaryConditions();
Crel.correctBoundaryConditions();
Krel.correctBoundaryConditions();
K_v.correctBoundaryConditions();
rho_m.correctBoundaryConditions();
cap_m.correctBoundaryConditions();
lambda_m.correctBoundaryConditions();
K_pt.correctBoundaryConditions();
